# 6 - Recap



* Para modelar relaciones entre data podemos hacer referencia a un documento embebido o a otro documento.
* Al hacer referencias a documentos no hay relacion real entre ellos asi que cuidado de que existan realmente
* Haciendo referencia a documentos es un buen enfoque si queremos consistencia. Esto hace que haya una sola instancia del objeto en la base, pero trae un impacto negativo en la performance de las queries porque MongoDB no hace join de documentos como las sql. Para hacer eso hay que mandar muchas queries a la bd.
* Embebiendo documentos soluciona ese problema de la performance trayendo todo en una query con sus hijos, pero implica muchas mas copias, algo que no molesta tanto en terminos de espacio \(hoy por hoy\) pero si a la hora de hacer update. Si falla durante un update queda inconsistente.
* “Can we tolerate data being inconsistent for a short period of time?"

## Referencing a document

```text
// Referencing a document
const courseSchema = new mongoose.Schema({
author: {
type: mongoose.Schema.Types.ObjectId,
ref: ‘Author’
}
})

// Referencing a document
const courseSchema = new mongoose.Schema({
author: {
type: new mongoose.Schema({
    name: String,
    bio: String
    })
}
})

- Embedded documents don’t have a save method. They can only be saved in the
context of their parent.
```

## Updating an embedded document

```text
// Updating an embedded document
const course = await Course.findById(courseId);
course.author.name = ‘New Name’;
course.save();
```

We don’t have transactions in MongoDB. To implement transactions, we use a pattern called “Two Phase Commit”. If you don’t want to manually implement this pattern, use the Fawn NPM package

```text
// Implementing transactions using Fawn
try {
await new Fawn.Task()
.save(‘rentals’, newRental)
.update(‘movies’, { _id: movie._id }, { $inc: numberInStock: -1 }})
.run();
}
catch (ex) {
// At this point, all operations are automatically rolled back
}
```

## Object IDS

* ObjectIDs are generated by MongoDB driver and are used to uniquely identify a

  document. They consist of 12 bytes:

* 4 bytes: timestamp
* 3 bytes: machine identifier
* 2 bytes: process identifier
* 3 byes: counter
* ObjectIDs are almost unique. In theory, there is a chance for two ObjectIDs to be

  equal but the odds are very low \(1/16,000,000\) for most real-world applications.

## Validating ObjectIDs

 mongoose.Types.ObjectID.isValid\(id\);

To validate ObjectIDs using joi, use joi-objectid NPM package.

